name: Gemini Code Review

on:
  # dev ë¸Œëœì¹˜ë¡œ ë“¤ì–´ì˜¤ëŠ” Pull Request ì‹œì—ë§Œ ì‹¤í–‰
  pull_request:
    branches: [ dev ]
    types: [ opened, synchronize, reopened ]

jobs:
  code-review:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set up Node
        uses: actions/setup-node@v3

      - name: Install GoogleGenerativeAI
        run: |
          npm install @google/generative-ai

      # PR ì´ë²¤íŠ¸ì—ì„œì˜ ë³€ê²½ì‚¬í•­ ì²˜ë¦¬
      - name: Get git diff for PR
        run: |
          git fetch origin "${{ github.event.pull_request.base.ref }}"
          git fetch origin "${{ github.event.pull_request.head.ref }}"
          git diff --unified=0 "origin/${{ github.event.pull_request.base.ref }}" > "diff.txt"

      # ë¦¬ë·° ìƒì„±ê³¼ ë²ˆì—­, PR ì½”ë©˜íŠ¸ë¥¼ í•œ ë²ˆì— ì²˜ë¦¬
      - name: Generate review, translate and add comments
        id: review_process
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require("fs");
            const { GoogleGenerativeAI } = require("@google/generative-ai");
            const genAI = new GoogleGenerativeAI("${{ secrets.GEMINI_API_KEY }}");
            
            // Pull Request ì •ë³´
            const prNumber = context.payload.pull_request.number;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            // 1. ì½”ë“œ ë¦¬ë·° ìƒì„±
            async function generateCodeReview() {
              try {
                const diff_output = fs.readFileSync("diff.txt", 'utf8');
                const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
            
                // Gemini API í˜¸ì¶œ - ì˜ì–´ë¡œ ê²°ê³¼ ìš”ì²­
                const prompt = `You are a senior software engineer and need to perform a code review based on the results of a given git diff. Review the changed code from different perspectives and let us know if there are any changes that need to be made. If you see any code that needs to be fixed in the result of the git diff, you need to calculate the exact line number by referring to the "@@ -0,0 +0,0 @@" part. 
            
                The output format is [{"path":"{ filepath }", "line": { line }, "text": "{ review comment in English only }", "side": "RIGHT"}] and this format must be strictly respected. Do not add any explanations before or after the JSON array.
            
                <git diff>${diff_output}</git diff>`;
            
                const result = await model.generateContent(prompt);
                const response = await result.response;
                const text = response.text();
            
                console.log("Raw Gemini Response:", text.substring(0, 500) + "...");
            
                // JSON íŒŒì‹± ì‹œë„
                let jsonData;
            
                // ì½”ë“œ ë¸”ë¡ ì œê±° ì‹œë„
                const cleanedText = text.replace(/```json\n|\n```|```/g, '');
            
                try {
                  // ì§ì ‘ íŒŒì‹± ì‹œë„
                  jsonData = JSON.parse(cleanedText);
                } catch (e) {
                  // ì‹¤íŒ¨ ì‹œ ì •ê·œ í‘œí˜„ì‹ìœ¼ë¡œ JSON ë°°ì—´ ì°¾ê¸°
                  const match = cleanedText.match(/\[[\s\S]*\]/);
                  if (match) {
                    jsonData = JSON.parse(match[0]);
                  } else {
                    throw new Error("Could not extract JSON array from response");
                  }
                }
            
                // ìœ íš¨ì„± ê²€ì‚¬: ë°°ì—´ì´ê³  í•­ëª©ì´ í•„ìš”í•œ í•„ë“œë¥¼ ê°€ì§€ê³  ìˆëŠ”ì§€
                if (!Array.isArray(jsonData)) {
                  throw new Error("Response is not a JSON array");
                }
            
                // í•„ìˆ˜ í•„ë“œ í™•ì¸ ë° í˜•ì‹ ê²€ì¦
                const validComments = jsonData.filter(item => {
                  return item.path && typeof item.line === 'number' && item.text && item.side;
                });
            
                console.log(`Extracted ${validComments.length} valid review comments`);
                return validComments;
              } catch (error) {
                console.error("Error generating code review:", error);
                return [];
              }
            }
            
            // 2. ë¦¬ë·° ì½”ë©˜íŠ¸ ë²ˆì—­
            async function translateComments(comments) {
              if (!comments || comments.length === 0) {
                console.log("No comments to translate");
                return comments;
              }
            
              try {
                const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
            
                // ëª¨ë“  ì½”ë©˜íŠ¸ í…ìŠ¤íŠ¸ë¥¼ ì¶”ì¶œ
                const textsToTranslate = comments.map(comment => comment.text);
            
                console.log("Translating", textsToTranslate.length, "comments");
            
                // ë²ˆì—­ì„ ìœ„í•œ í”„ë¡¬í”„íŠ¸ êµ¬ì„±
                const translationPrompt = `
                Translate the following English code review comments to Korean accurately. 
                Maintain the technical terms as is when appropriate. Return each translated text in the same order in a JSON array.
            
                ${JSON.stringify(textsToTranslate)}
                `;
            
                // ë²ˆì—­ ìš”ì²­
                const translationResult = await model.generateContent(translationPrompt);
                const translationResponse = await translationResult.response;
                const translationText = translationResponse.text();
            
                console.log("Raw translation response:", translationText.substring(0, 500) + "...");
            
                let translatedTexts;
                try {
                  // ë²ˆì—­ëœ ê²°ê³¼ì—ì„œ JSON ë°°ì—´ ì¶”ì¶œ ì‹œë„
                  const match = translationText.match(/\[[\s\S]*\]/);
                  if (match) {
                    translatedTexts = JSON.parse(match[0]);
                  } else {
                    // JSON ë°°ì—´ í˜•ì‹ì´ ì•„ë‹ˆë¼ë©´ ì§ì ‘ íŒŒì‹± ì‹œë„
                    translatedTexts = JSON.parse(translationText);
                  }
            
                  // ë°°ì—´ì´ ì•„ë‹Œ ê²½ìš° ì˜¤ë¥˜
                  if (!Array.isArray(translatedTexts)) {
                    throw new Error("Translation result is not an array");
                  }
            
                  // ë²ˆì—­ëœ í…ìŠ¤íŠ¸ ê°œìˆ˜ê°€ ì›ë³¸ê³¼ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸
                  if (translatedTexts.length !== comments.length) {
                    console.warn(`Translation count mismatch: got ${translatedTexts.length}, expected ${comments.length}`);
                    throw new Error("Translation count mismatch");
                  }
            
                  // ë²ˆì—­ëœ í…ìŠ¤íŠ¸ë¥¼ ì›ë³¸ ì½”ë©˜íŠ¸ì— ì ìš©
                  const translatedComments = comments.map((comment, index) => ({
                    ...comment,
                    text: translatedTexts[index]
                  }));
            
                  console.log("Successfully translated all comments");
                  return translatedComments;
                } catch (error) {
                  console.error("Error processing translation:", error);
                  console.log("Using original English comments due to translation error");
                  return comments;
                }
              } catch (error) {
                console.error("Error in translation process:", error);
                return comments;
              }
            }
            
            // 3. PRì— ë¦¬ë·° ì½”ë©˜íŠ¸ ì¶”ê°€
            async function addReviewComments(comments) {
              if (!comments || comments.length === 0) {
                console.log("No review comments to add");
                return;
              }
            
              try {
                console.log(`Adding ${comments.length} review comments...`);
            
                // ì „ì²´ ë¦¬ë·°ë¥¼ ìƒì„±í•˜ê³  ê°œë³„ ì½”ë©˜íŠ¸ ì¶”ê°€
                const review = await github.rest.pulls.createReview({
                  owner,
                  repo,
                  pull_number: prNumber,
                  event: 'COMMENT',
                  body: 'ğŸ¤– Gemini Code Review - ìë™ ì½”ë“œ ë¦¬ë·° ê²°ê³¼ì…ë‹ˆë‹¤.',
                  comments: comments.map(comment => ({
                    path: comment.path,
                    line: comment.line,
                    body: comment.text,
                    side: comment.side.toLowerCase()
                  }))
                });
            
                console.log(`Review created with ID: ${review.data.id}`);
                return review.data.id;
              } catch (error) {
                console.error("Error creating PR review:", error);
                throw error;
              }
            }
            
            // ì „ì²´ í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰
            async function runReviewProcess() {
              try {
                // 1. ì½”ë“œ ë¦¬ë·° ìƒì„±
                const reviewComments = await generateCodeReview();
            
                if (reviewComments.length === 0) {
                  console.log("No review comments generated, ending process");
                  return;
                }
            
                // 2. ë¦¬ë·° ì½”ë©˜íŠ¸ ë²ˆì—­
                const translatedComments = await translateComments(reviewComments);
            
                // 3. PRì— ë¦¬ë·° ì½”ë©˜íŠ¸ ì¶”ê°€
                await addReviewComments(translatedComments);
            
                console.log("Review process completed successfully");
              } catch (error) {
                console.error("Review process failed:", error);
                core.setFailed(`Review process failed: ${error.message}`);
              }
            }
            
            // í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰
            return runReviewProcess();