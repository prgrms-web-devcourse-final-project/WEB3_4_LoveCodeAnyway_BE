name: Gemini Code Review

on:
  # dev Î∏åÎûúÏπòÎ°ú Îì§Ïñ¥Ïò§Îäî Pull Request ÏãúÏóêÎßå Ïã§Ìñâ
  pull_request:
    branches: [ dev ]
    types: [ opened, synchronize, reopened ]

jobs:
  code-review:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set up Node
        uses: actions/setup-node@v3

      - name: Install GoogleGenerativeAI
        run: |
          npm install @google/generative-ai

      # PR Ïù¥Î≤§Ìä∏ÏóêÏÑúÏùò Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Ï≤òÎ¶¨
      - name: Get git diff for PR
        run: |
          git fetch origin "${{ github.event.pull_request.base.ref }}"
          git fetch origin "${{ github.event.pull_request.head.ref }}"
          git diff --unified=0 "origin/${{ github.event.pull_request.base.ref }}" > "diff.txt"

      # GeminiÎ•º ÏÇ¨Ïö©Ìïú ÏΩîÎìú Î∂ÑÏÑù
      - name: Run Gemini-1.5-flash for Code Review
        id: gemini_review
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");
            const diff_output = fs.readFileSync("diff.txt",'utf8');

            const { GoogleGenerativeAI } = require("@google/generative-ai");
            const genAI = new GoogleGenerativeAI("${{ secrets.GEMINI_API_KEY }}");
            const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash"});            

            // Gemini API Ìò∏Ï∂ú - ÏòÅÏñ¥Î°ú Í≤∞Í≥º ÏöîÏ≤≠
            const prompt = `You are a senior software engineer and need to perform a code review based on the results of a given git diff. Review the changed code from different perspectives and let us know if there are any changes that need to be made. If you see any code that needs to be fixed in the result of the git diff, you need to calculate the exact line number by referring to the "@@ -0,0 +0,0 @@" part. The output format is \[{"path":"{ filepath }", "line": { line }, "text": { review comment in English only }, "side": "RIGHT"}\] and this format must be strictly respected. Do not add any explanations before or after the JSON array.\n<git diff>${diff_output}</git diff>`;

            const result = await model.generateContent(prompt);
            const response = await result.response;
            const text = response.text();
            
            // ÏùëÎãµ Ï†ÄÏû•
            fs.writeFileSync('review_result_original.txt', text);
            
            try {
              // JSON ÌååÏã± ÏãúÎèÑ
              let jsonData;
            
              // ÏΩîÎìú Î∏îÎ°ù Ï†úÍ±∞ ÏãúÎèÑ
              const cleanedText = text.replace(/```json\n|\n```|```/g, '');
            
              try {
                // ÏßÅÏ†ë ÌååÏã± ÏãúÎèÑ
                jsonData = JSON.parse(cleanedText);
              } catch (e) {
                // Ïã§Ìå® Ïãú Ï†ïÍ∑ú ÌëúÌòÑÏãùÏúºÎ°ú JSON Î∞∞Ïó¥ Ï∞æÍ∏∞
                const match = cleanedText.match(/\[[\s\S]*\]/);
                if (match) {
                  jsonData = JSON.parse(match[0]);
                } else {
                  throw new Error("Could not extract JSON array from response");
                }
              }
            
              // Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨: Î∞∞Ïó¥Ïù¥Í≥† Ìï≠Î™©Ïù¥ ÌïÑÏöîÌïú ÌïÑÎìúÎ•º Í∞ÄÏßÄÍ≥† ÏûàÎäîÏßÄ
              if (!Array.isArray(jsonData)) {
                throw new Error("Response is not a JSON array");
              }
            
              // ÌïÑÏàò ÌïÑÎìú ÌôïÏù∏ Î∞è ÌòïÏãù Í≤ÄÏ¶ù
              jsonData = jsonData.map(item => {
                if (!item.path || typeof item.line !== 'number' || !item.text || !item.side) {
                  throw new Error(`Invalid item format: ${JSON.stringify(item)}`);
                }
            
                return {
                  path: item.path,
                  line: item.line,
                  text: item.text,
                  side: item.side
                };
              });
            
              // Ï†ïÏ†úÎêú JSON Ï†ÄÏû•
              fs.writeFileSync('review_result_en.json', JSON.stringify(jsonData, null, 2));
              console.log("Successfully parsed and validated the review result.");
            
              return jsonData;
            } catch (error) {
              console.error("Error parsing Gemini response:", error);
              fs.writeFileSync('error.txt', error.toString());
              return [];
            }

      # ÏòÅÏñ¥Î°ú Îêú Î¶¨Î∑∞ ÏΩîÎ©òÌä∏Î•º ÌïúÍµ≠Ïñ¥Î°ú Î≤àÏó≠
      - name: Translate review comments to Korean
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            try {
              const reviewCommentsJson = fs.readFileSync('review_result_en.json', 'utf8');
              const comments = JSON.parse(reviewCommentsJson);
            
              if (!comments || comments.length === 0) {
                console.log("No review comments to translate.");
                return [];
              }
            
              console.log(`Translating ${comments.length} review comments to Korean...`);
            
              const { GoogleGenerativeAI } = require("@google/generative-ai");
              const genAI = new GoogleGenerativeAI("${{ secrets.GEMINI_API_KEY }}");
              const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash"});
            
              // Î™®Îì† ÏΩîÎ©òÌä∏ ÌÖçÏä§Ìä∏Î•º Ï∂îÏ∂ú
              const textsToTranslate = comments.map(comment => comment.text);
            
              // Î≤àÏó≠ÏùÑ ÏúÑÌïú ÌîÑÎ°¨ÌîÑÌä∏ Íµ¨ÏÑ±
              const translationPrompt = `
              Translate the following English code review comments to Korean accurately. 
              Maintain the technical terms as is when appropriate. Return only the translated text in the same array format.
            
              ${JSON.stringify(textsToTranslate)}
              `;
            
              // Î≤àÏó≠ ÏöîÏ≤≠
              const translationResult = await model.generateContent(translationPrompt);
              const translationResponse = await translationResult.response;
              const translationText = translationResponse.text();
            
              // Î≤àÏó≠ Í≤∞Í≥º Ï†ÄÏû•
              fs.writeFileSync('translation_result.txt', translationText);
            
              let translatedTexts;
              try {
                // Î≤àÏó≠Îêú Í≤∞Í≥ºÏóêÏÑú JSON Î∞∞Ïó¥ Ï∂îÏ∂ú ÏãúÎèÑ
                const match = translationText.match(/\[[\s\S]*\]/);
                if (match) {
                  translatedTexts = JSON.parse(match[0]);
                } else {
                  // JSON Î∞∞Ïó¥ ÌòïÏãùÏù¥ ÏïÑÎãàÎùºÎ©¥ ÏßÅÏ†ë ÌååÏã± ÏãúÎèÑ
                  translatedTexts = JSON.parse(translationText);
                }
            
                // Î∞∞Ïó¥Ïù¥ ÏïÑÎãå Í≤ΩÏö∞ Ïò§Î•ò
                if (!Array.isArray(translatedTexts)) {
                  throw new Error("Translation result is not an array");
                }
            
                // Î≤àÏó≠Îêú ÌÖçÏä§Ìä∏ Í∞úÏàòÍ∞Ä ÏõêÎ≥∏Í≥º ÏùºÏπòÌïòÎäîÏßÄ ÌôïÏù∏
                if (translatedTexts.length !== comments.length) {
                  throw new Error(`Translation count mismatch: got ${translatedTexts.length}, expected ${comments.length}`);
                }
            
                // Î≤àÏó≠Îêú ÌÖçÏä§Ìä∏Î•º ÏõêÎ≥∏ ÏΩîÎ©òÌä∏Ïóê Ï†ÅÏö©
                const translatedComments = comments.map((comment, index) => ({
                  ...comment,
                  text: translatedTexts[index]
                }));
            
                // Î≤àÏó≠Îêú ÏΩîÎ©òÌä∏ Ï†ÄÏû•
                fs.writeFileSync('review_result_ko.json', JSON.stringify(translatedComments, null, 2));
                console.log("Successfully translated all comments.");
            
                return translatedComments;
              } catch (error) {
                console.error("Error processing translation:", error);
                console.log("Using original English comments due to translation error.");
                return comments;
              }
            } catch (error) {
              console.error("Error loading review comments:", error);
              return [];
            }

      # Î≤àÏó≠Îêú ÏΩîÎ©òÌä∏Î°ú PR Î¶¨Î∑∞ Ï∂îÍ∞Ä
      - name: Add PR review comments
        if: success()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            
            try {
              // Î≤àÏó≠Îêú ÏΩîÎ©òÌä∏Í∞Ä ÏûàÏúºÎ©¥ ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ ÏòÅÏñ¥ ÏΩîÎ©òÌä∏ ÏÇ¨Ïö©
              let reviewCommentsFile = 'review_result_ko.json';
              if (!fs.existsSync(reviewCommentsFile)) {
                reviewCommentsFile = 'review_result_en.json';
                console.log("Using original English comments as Korean translation not available.");
              }
            
              const reviewCommentsJson = fs.readFileSync(reviewCommentsFile, 'utf8');
              const comments = JSON.parse(reviewCommentsJson);
            
              if (!comments || comments.length === 0) {
                console.log("No review comments to add.");
                return;
              }
            
              console.log(`Adding ${comments.length} review comments...`);
            
              // Pull Request Ï†ïÎ≥¥
              const prNumber = context.payload.pull_request.number;
              const owner = context.repo.owner;
              const repo = context.repo.repo;
            
              // Ï†ÑÏ≤¥ Î¶¨Î∑∞Î•º ÏÉùÏÑ±ÌïòÍ≥† Í∞úÎ≥Ñ ÏΩîÎ©òÌä∏ Ï∂îÍ∞Ä
              const review = await github.rest.pulls.createReview({
                owner,
                repo,
                pull_number: prNumber,
                event: 'COMMENT', // 'APPROVE', 'REQUEST_CHANGES'ÎèÑ Í∞ÄÎä•
                body: 'ü§ñ Gemini Code Review - ÏûêÎèô ÏΩîÎìú Î¶¨Î∑∞ Í≤∞Í≥ºÏûÖÎãàÎã§.',
                comments: comments.map(comment => ({
                  path: comment.path,
                  line: comment.line,
                  body: comment.text,
                  side: comment.side.toLowerCase()
                }))
              });
            
              console.log(`Review created with ID: ${review.data.id}`);
            } catch (error) {
              console.error("Error creating PR review:", error);
              core.setFailed(`Failed to create PR review: ${error.message}`);
            }